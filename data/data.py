''' 
    setting up the datasets for ggnn
'''

import init_path

# system import
from copy import deepcopy

# compute
import numpy as np
import random

# torch import
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
import torch.utils.data as data_utils
import torchvision.transforms as transforms

# local imports

class VerifyGraphDataset(data_utils.Dataset):
    
    def __init__(self, samples, args, valset=False):
        self.samples = samples
        self.args = args
        if not valset:
            self.valset = False
            self.graph_size = args.graph_size
        else:
            self.valset = True
            self.graph_size = args.val_graph_size

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, index):
        '''
        '''
        g1 = self.samples[index]

        # the isomorphic graph
        g1_prime = deepcopy(g1)
        g1_prime.generate_isomorphic()

        # randomly sample another graph
        g2 = Graph(self.args, valset_graph=self.valset)
        while g2.same_connection(g1):
            g2 = Graph(self.args, valset_graph=self.valset)

        # need to return initial state, annotation, and adjacency matrix
        # initial states are random
        g1_state = np.random.rand(self.graph_size, self.args.state_dim)
        g1_prime_state = np.random.rand(self.graph_size, self.args.state_dim)
        g2_state = np.random.rand(self.graph_size, self.args.state_dim)
        # g1_state = np.ones( (self.args.graph_size, self.args.state_dim) )
        # g1_prime_state = np.ones( (self.args.graph_size, self.args.state_dim) )
        # g2_state = np.ones( (self.args.graph_size, self.args.state_dim) )
        

        # annotation state is generated by the given attributes
        g1_anno = np.stack(g1.attr_list)
        g1_prime_anno = np.stack(g1_prime.attr_list)
        g2_anno = np.stack(g2.attr_list)

        # adjacency matrix
        g1_mat = compact2sparse_representation(g1.mat, self.args.edge_type)
        g1_prime_mat = compact2sparse_representation(g1_prime.mat, self.args.edge_type)
        g2_mat = compact2sparse_representation(g2.mat, self.args.edge_type)


        # if random.randint(0, 1) == 1: # use same positive example
        #     label = np.array([1]).astype('float32')
        #     state_mat = np.dstack( (g1_state, g1_prime_state) )
        #     state_mat = np.transpose(state_mat, (2, 0, 1))
        #     anno_mat = np.dstack( (g1_anno, g1_prime_anno) )
        #     anno_mat = np.transpose(anno_mat, (2, 0, 1))
        #     adj_mat = np.dstack( ( g1_mat, g1_prime_mat) )
        #     adj_mat = np.transpose(adj_mat, (2, 0, 1))
        # else:
        #     label = np.array([0]).astype('float32')
        #     state_mat = np.dstack( (g1_state, g2_state) )
        #     state_mat = np.transpose(state_mat, (2, 0, 1))
        #     anno_mat = np.dstack( (g1_anno, g2_anno) )
        #     anno_mat = np.transpose(anno_mat, (2, 0, 1))
        #     adj_mat = np.dstack( ( g1_mat, g2_mat) )
        #     adj_mat = np.transpose(adj_mat, (2, 0, 1))

        label = np.array([1, 0]).astype('float32')
        state_mat = np.dstack( (g1_state, g1_prime_state, g1_state, g2_state) )
        state_mat = np.transpose(state_mat, (2, 0, 1))
        anno_mat = np.dstack( (g1_anno, g1_prime_anno, g1_anno, g2_anno) )
        anno_mat = np.transpose(anno_mat, (2, 0, 1))
        adj_mat = np.dstack( ( g1_mat, g1_prime_mat, g1_mat, g2_mat) )
        adj_mat = np.transpose(adj_mat, (2, 0, 1))


        return state_mat.astype('float32'), anno_mat.astype('float32'), \
               adj_mat.astype('float32'), label

def get_dloader(args, num, val_set=False, test=False):
    '''
    '''
    data = generate_graph(num, args, val_set)
    dataset = VerifyGraphDataset(data, args, valset=val_set)
    if test:
        dataloader = data_utils.DataLoader(dataset,
            batch_size=args.bs
        )
    else:
        dataloader = data_utils.DataLoader(dataset, 
            args.bs, pin_memory=False, 
            num_workers=args.num_workers
        )
    return dataloader

def generate_graph(num, args, val_set):
    ''' generate <num> number of graphs for GGNN
    return a list of Graph structures
    '''
    graph_list = []

    for i in range(num):
        graph_list.append(
            Graph(args, valset_graph=val_set)
        )
        pass
    return graph_list

def compact2sparse_representation(mat, total_edge_type):
    ''' convert a compact adjacent matrix to a sparse matrix
    '''
    N, _ = mat.shape
    total_edge_type = total_edge_type
    
    sparse_mat = np.zeros((N, N * total_edge_type * 2))
        
    # fill the in's and out's in the sparse matrix
    for i in range(N):
        for j in range(N):
            if mat[i, j] == 0: continue
            
            edge_type = mat[i, j]
            _from = i
            _to   = j
            
            # fill in
            in_x = j
            in_y = i + N * (edge_type - 1)
            sparse_mat[int(in_x), int(in_y)] = 1
            
            # fill out
            # need to skip all the in's
            out_x = i
            out_y = N * total_edge_type + j + N * (edge_type - 1)
            sparse_mat[int(out_x), int(out_y)] = 1
    return sparse_mat.astype('int')

def adj_mat2list(mat):
    ''' convert an adjacency matrix to a list
        return:
            a dictionary - key: node id
                           val: node id that connects to
    '''
    N, _ = mat.shape
    adj_list = {}
    
    for i in range(N):
        adj_list[i] = np.where(mat[i] != 0)[0].tolist()
    
    return adj_list

def adj_list2mat(adj_list):
    ''' convert an adjacency list to a matrix
        input:
            a dictionary of size N describing the connection
            relationship
        return:
            a numpy array (N x N) describing the connection
            between nodes
    '''
    N = len(adj_list)
    mat = np.zeros((N, N))
    
    for node, connected_nodes in adj_list.items():
        for x in connected_nodes:
            mat[node][x] = 1
    return mat.astype(int)

def generate_isomorphic_graph(adj_list):
    ''' @brief: generate an isomorphic graph based on 
                the adjacency matrix
        return: a new adj_list that is isomorphic
                to the graph described by the adj_list
    '''
    N = len(adj_list)
    
    # shuffle the list to get a new one
    original_order = list(range(N))    
    shuffled_order = list(range(N))
    random.shuffle( shuffled_order )
    # construct a mapping from the old index to the new index
    old2new_index = {}
    for i, x in enumerate(shuffled_order):
        old2new_index[x] = original_order[i]

    # construct the new adj_list
    new_adj_list = {}
    for i, x in enumerate(shuffled_order):
        new_adj_list[i] = []
        for y in adj_list[x]:
            new_adj_list[i].append( old2new_index[y] )
    
    return new_adj_list

class Graph():

    def __init__(self, args, valset_graph=False):

        self.args = args

        if valset_graph:
            self.graph_size = self.args.val_graph_size
        else:
            self.graph_size = self.args.graph_size


        self.mat = self._generate_connection(
            self.graph_size, self.args.edge_type,
            self.args.connection_rate
        )
        self.attr_list = self._generate_node_attr(
            self.graph_size, self.args.node_type,
            self.args.random_embed
        )
        self.graph_size = args.graph_size

    def __eq__(self, other):

        if self.graph_size != other.graph_size: return False

        if np.array_equal(self.mat, other.mat) == False: return False

        for i in range(self.args.graph_size):
            if np.array_equal(self.attr_list[i], other.attr_list[i]) \
                == False: 
                return False

        return True

    def generate_isomorphic(self):
        ''' recreate a new adjacency matrix
        and replace the current
        '''
        cur_adj_list = adj_mat2list(self.mat)
        iso_adj_list = generate_isomorphic_graph(cur_adj_list)
        self.mat     = adj_list2mat(iso_adj_list)

        return

    def same_connection(self, other):
        ''' 2 graphs having the same connection
        edge type is also the same
        '''
        if np.array_equal(self.mat, other.mat): return True
        return False

    def resample_attr(self):
        ''' resample new attributes
        '''
        self.attr_list = self._generate_node_attr(
            self.args.graph_size, self.args.node_type,
            self.args.random_embed
        )
        return None

    def _generate_connection(self, size, edge_type=3, connect_rate=0.1):
        ''' generated a connected graph
        in the from of adjacency matrix
        '''
        mat = np.zeros((size, size))
        
        node_id = 0
        while node_id < size:
            connected = False
            
            # flip coin on column
            for i in range(size):
                if i == node_id: continue
                if np.random.binomial(1, connect_rate, 1):
                    mat[i, node_id] = random.randint(1, edge_type)
                    connected = True
                    
            # flip coin on row
            for i in range(size):
                if i == node_id: continue
                if np.random.binomial(1, connect_rate, 1):
                    mat[node_id, i] = random.randint(1, edge_type)
                    connected = True
            
            if connected == False: 
                pass
            else:
                node_id += 1
                
        return mat

    def _generate_node_attr(self, size, node_type=3, random_embed=False, zero=True):
        ''' generate the node attributes of the corresponding graph
        '''
        node_attr_list = []

        for i in range(size):

            if random_embed:
                attr = np.random.rand(self.args.anno_dim)
            else:
                attr = np.zeros(self.args.anno_dim)
                attr[random.randint(0, self.args.anno_dim-1)] = 1

            if zero:
                attr = np.zeros(self.args.anno_dim)


            node_attr_list.append(attr)

        return node_attr_list



if __name__ == '__main__':
    pass
    from config import config
    from model import verify_model
    from util import util
    args = config.get_config()

    bs = args.bs
    n_node = args.graph_size
    n_node_type = args.node_type
    node_anno_dim = args.anno_dim
    node_state_dim = args.state_dim
    n_edge_type = args.edge_type
    t_step = args.prop_ts
    output_dim = args.output_size

    model = verify_model.verifyGraphModel(
        args, 
        n_node, n_node_type,
        node_anno_dim, node_state_dim, 
        n_edge_type, 
        t_step,
        output_dim
    )

    dloader = get_dloader(args, args.val_dataset_size, val_set=True, test=True)
    for data_point in dloader:

        x1, x2, x3, y = data_point
        import pdb; pdb.set_trace()
        x1, x2, x3, y = util.check_gpu(args.gpu, x1, x2, x3, y)
        yhat = model(x1, x2, x3)

        print('+', end='')
        pass


    